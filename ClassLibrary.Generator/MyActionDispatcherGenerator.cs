using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace ClassLibrary.Generator;

[Generator(LanguageNames.CSharp)]
public class MyActionDispatcherGenerator : IIncrementalGenerator
{
    private const string AttributeName = "MyAction";
    private const string FullyQualifiedMetadataName = "ClassLibrary.MyActionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //System.Diagnostics.Debugger.Launch();
        // Create a provider for methods with the [MyAction] attribute
        var methodsWithMyAction = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: FullyQualifiedMetadataName,
                predicate: static (node, _) => node is BaseMethodDeclarationSyntax method && method.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword)),
                transform: static (context, _) => GetMethodWithMyActionAttribute(context)
            )
            .Where(static method => method is not null)
            .Collect();

        // Register the source output
        context.RegisterSourceOutput(methodsWithMyAction, GenerateDispatcher);
    }

    private static (string? ClassName, string? MethodName)? GetMethodWithMyActionAttribute(GeneratorAttributeSyntaxContext context)
    {
        var methodSyntax = (MethodDeclarationSyntax)context.TargetNode;
        var semanticModel = context.SemanticModel;

        // Get the class containing the method
        var classDeclaration = methodSyntax.Parent as ClassDeclarationSyntax;
        var className = classDeclaration?.Identifier.Text;

        // Get the method name
        var methodName = methodSyntax.Identifier.Text;

        // Check for the [MyAction] attribute
        var attributes = methodSyntax.AttributeLists
            .SelectMany(attrList => attrList.Attributes)
            .Select(attr => semanticModel.GetSymbolInfo(attr).Symbol)
            .Cast<IMethodSymbol>();

        var myActionAttribute = attributes
            .FirstOrDefault(attr => attr.ContainingType.Name == $"{AttributeName}Attribute");

        if (myActionAttribute != null)
        {
            return (className, methodName);
        }

        return null;
    }

    private static void GenerateDispatcher(SourceProductionContext context, ImmutableArray<(string? ClassName, string? MethodName)?> methods)
    {
        // Filter null values
        var validMethods = methods
            .Where(m => m is not null)
            .Select(m => m!.Value)
            .ToArray();

        if (validMethods.Length == 0)
            return;

        // Generate the dispatcher class
        var sourceBuilder = new StringBuilder();

        sourceBuilder.AppendLine("""
            using System;

            namespace ClassLibrary;

            /*
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            This class is auto-generated by MyActionDispatcherGenerator.
            Please DO NOT modify it manually!
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            */
            public class MyGeneratedActionDispatcher : IActionDispatcher
            {
                public void Dispatch(string actionName)
                {
                    switch (actionName)
                    {
            """);

        foreach (var (className, methodName) in validMethods)
        {
            sourceBuilder.AppendLine($"            case \"{methodName}\":");
            sourceBuilder.AppendLine($"                {className}.{methodName}();");
            sourceBuilder.AppendLine("                return;");
        }

        sourceBuilder.Append("""
                        default:
                            throw new ArgumentException($"No action found for: {actionName}");
                    }
                }
            }
            """);

        context.AddSource("MyActionDispatcher.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }
}