using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace ClassLibrary.Generator;

[Generator(LanguageNames.CSharp)]
public class MyActionDispatcherGenerator : IIncrementalGenerator
{
    private const string FullyQualifiedMetadataName = "ClassLibrary.MyActionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a provider for methods with the [MyAction] attribute
        var methodsWithMyAction = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: FullyQualifiedMetadataName,
                predicate: static (node, _) => node is BaseMethodDeclarationSyntax method && method.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword)),
                transform: static (context, _) => GetMethodWithMyActionAttribute(context)
            )
            .Where(static method => method is not null)
            .Collect();

        // Register the source output
        context.RegisterSourceOutput(methodsWithMyAction, GenerateDispatcher);
    }

    private static (string? ClassName, string? MethodName, ImmutableArray<IParameterSymbol> Parameters)? GetMethodWithMyActionAttribute(GeneratorAttributeSyntaxContext context)
    {
        var methodSyntax = (MethodDeclarationSyntax)context.TargetNode;
        var semanticModel = context.SemanticModel;

        // Get the class containing the method
        var classDeclaration = methodSyntax.Parent as ClassDeclarationSyntax;
        var className = classDeclaration?.Identifier.Text;

        // Get the method symbol
        if (semanticModel.GetDeclaredSymbol(methodSyntax) is IMethodSymbol methodSymbol)
        {
            return (className, methodSymbol.Name, methodSymbol.Parameters);
        }

        return null;
    }

    private static void GenerateDispatcher(SourceProductionContext context, ImmutableArray<(string? ClassName, string? MethodName, ImmutableArray<IParameterSymbol> Parameters)?> methods)
    {
        // Filter null values
        var validMethods = methods
            .Where(m => m is not null)
            .Select(m => m!.Value)
            .ToArray();

        if (validMethods.Length == 0)
            return;

        // Generate the dispatcher class
        var sourceBuilder = new StringBuilder();

        sourceBuilder.AppendLine("""
            using System;
            using System.Globalization;

            namespace ClassLibrary;

            /*
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            This class is auto-generated by MyActionDispatcherGenerator.
            Please DO NOT modify it manually!
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            */
            public class MyGeneratedActionDispatcher : IActionDispatcher
            {
                public void Dispatch(string actionName, params string[] args)
                {
                    switch (actionName)
                    {
            """);

        foreach (var (className, methodName, parameters) in validMethods)
        {
            sourceBuilder.AppendLine($"            case \"{methodName}\":");

            if (parameters.Length > 0)
            {
                sourceBuilder.AppendLine("                if (args.Length != " + parameters.Length + ")");
                sourceBuilder.AppendLine($"                    throw new ArgumentException($\"Expected {parameters.Length} arguments for {methodName}, but got {{args.Length}}.\");");

                var parsedArgs = new StringBuilder();
                for (int i = 0; i < parameters.Length; i++)
                {
                    var param = parameters[i];
                    var parseMethod = GetParseMethod(param.Type);

                    if (parseMethod is null)
                    {
                        parsedArgs.Append($"args[{i}]");
                    }
                    else if (parseMethod == "Boolean.Parse")
                    {
                        parsedArgs.Append($"{parseMethod}(args[{i}])");
                    }
                    else
                    {
                        parsedArgs.Append($"{parseMethod}(args[{i}], CultureInfo.InvariantCulture)");
                    }

                    if (i < parameters.Length - 1)
                        parsedArgs.Append(", ");
                }

                sourceBuilder.AppendLine($"                {className}.{methodName}({parsedArgs});");
            }
            else
            {
                sourceBuilder.AppendLine($"                {className}.{methodName}();");
            }

            sourceBuilder.AppendLine("                return;");
        }

        sourceBuilder.Append("""
                        default:
                            throw new ArgumentException($"No action found for: {actionName}");
                    }
                }
            }
            """);

        context.AddSource("MyActionDispatcher.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    private static string? GetParseMethod(ITypeSymbol typeSymbol)
    {
        var type = typeSymbol.ToDisplayString();

        return type switch
        {
            "int" or "System.Int32" => "Int32.Parse",
            "float" or "System.Single" => "Single.Parse",
            "double" or "System.Double" => "Double.Parse",
            "decimal" or "System.Decimal" => "Decimal.Parse",
            "System.DateTime" => "DateTime.Parse",
            "bool" or "System.Boolean" => "Boolean.Parse",
            "string" or "System.String" => null,
            _ => throw new NotSupportedException($"Type {type} is not supported."),
        };
    }
}
