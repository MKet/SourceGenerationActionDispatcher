using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace ClassLibrary.Generator;

[Generator(LanguageNames.CSharp)]
public class MyActionDispatcherGenerator : IIncrementalGenerator
{
    private const string FullyQualifiedMetadataName = "ClassLibrary.MyActionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Identify methods with the [MyAction] attribute
        var methodsWithMyAction = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                FullyQualifiedMetadataName,
                static (node, _) => node is MethodDeclarationSyntax method &&
                                     method.Modifiers.Any(SyntaxKind.StaticKeyword) &&
                                     method.ReturnType.ToString() is "string" or "System.String",
                static (context, _) => ExtractMethodData(context)
            )
            .Where(static method => method is not null)
            .Collect();

        // Register the source output
        context.RegisterSourceOutput(methodsWithMyAction, GenerateDispatcher);
    }

    private static (string? ClassName, string? MethodName, ImmutableArray<IParameterSymbol> Parameters)? ExtractMethodData(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetNode is not MethodDeclarationSyntax methodSyntax ||
            methodSyntax.Parent is not ClassDeclarationSyntax classSyntax ||
            context.SemanticModel.GetDeclaredSymbol(methodSyntax) is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        var className = classSyntax.Identifier.Text;
        return (className, methodSymbol.Name, methodSymbol.Parameters);
    }

    private static void GenerateDispatcher(SourceProductionContext context, ImmutableArray<(string? ClassName, string? MethodName, ImmutableArray<IParameterSymbol> Parameters)?> methods)
    {
        var validMethods = methods.Where(m => m is not null).Select(m => m!.Value).ToArray();

        var sourceBuilder = new StringBuilder();

        AppendHeader(sourceBuilder);
        AppendDispatchMethod(sourceBuilder, validMethods);
        AppendFooter(sourceBuilder);

        context.AddSource("MyActionDispatcher.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    private static void AppendHeader(StringBuilder builder)
    {
        builder.AppendLine("""
            using System;
            using System.Globalization;

            namespace ClassLibrary;

            /*
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            This class is auto-generated by MyActionDispatcherGenerator.
            Please DO NOT modify it manually!
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            */
            public class MyGeneratedActionDispatcher : IActionDispatcher
            {
            """);
    }

    private static void AppendDispatchMethod(StringBuilder builder, (string? ClassName, string? MethodName, ImmutableArray<IParameterSymbol> Parameters)[] methods)
    {
        builder.AppendLine("""
            public string Dispatch(string actionName, params string[] args)
            {
        """);

        if (methods.Length == 0)
        {
            builder.AppendLine("            throw new NotSupportedException(\"There are no valid methods to be called via the ActionDispatcher.\");");
        }
        else
        {
            builder.AppendLine("""                
                        switch (actionName)
                        {
                """);

            foreach (var (className, methodName, parameters) in methods)
            {
                builder.AppendLine($"            case \"{methodName}\":");
                builder.AppendLine("            {");
                builder.AppendLine($"                if (args.Length != {parameters.Length})");
                builder.AppendLine("                {");
                builder.AppendLine($"                    throw new ArgumentException($\"Expected {parameters.Length} arguments for {methodName}, but got {{args.Length}}.\");");
                builder.AppendLine("                }");

                if (parameters.Length > 0)
                {
                    var parsedArgs = BuildArgumentParsing(parameters);
                    builder.AppendLine($"                return {className}.{methodName}({parsedArgs});");
                }
                else
                {
                    builder.AppendLine($"                return {className}.{methodName}();");
                }

                builder.AppendLine("            }");
            }


            builder.AppendLine("""
                        default:
                        {
                            throw new ArgumentException($"No action found for: {actionName}");
                        }
                    }
            """);
        }
    }

    private static string BuildArgumentParsing(ImmutableArray<IParameterSymbol> parameters)
    {
        var parsedArgs = new StringBuilder();
        for (int i = 0; i < parameters.Length; i++)
        {
            var parameter = parameters[i];
            var parseMethod = GetParseMethod(parameter.Type);

            if (parseMethod == null)
            {
                parsedArgs.Append($"args[{i}]");
            }
            else if (parseMethod == "Boolean.Parse")
            {
                parsedArgs.Append($"{parseMethod}(args[{i}])");
            }
            else
            {
                parsedArgs.Append($"{parseMethod}(args[{i}], CultureInfo.InvariantCulture)");
            }

            if (i < parameters.Length - 1)
            {
                parsedArgs.Append(", ");
            }
        }

        return parsedArgs.ToString();
    }

    private static string? GetParseMethod(ITypeSymbol typeSymbol)
    {
        var typeName = typeSymbol.ToDisplayString();

        return typeName switch
        {
            "int" or "System.Int32" => "Int32.Parse",
            "float" or "System.Single" => "Single.Parse",
            "double" or "System.Double" => "Double.Parse",
            "decimal" or "System.Decimal" => "Decimal.Parse",
            "bool" or "System.Boolean" => "Boolean.Parse",
            "System.DateTime" => "DateTime.Parse",
            "string" or "System.String" => null,
            _ => throw new NotSupportedException($"Type '{typeName}' is not supported."),
        };
    }

    private static void AppendFooter(StringBuilder builder)
    {
        builder.AppendLine("    }");
        builder.AppendLine("}");
    }
}